# 객체를 활용한 해시 테이블 만들기
# 딕셔너리가 테이블 역할 을 할 수 있지 않을까
# csv 파일을 활용하여 표적 데이터 불러오기
# 구글 폼, 네이버 폼에서 제공하는 질의 응답의 결과를 csv로 저장하기
# 피료한 테이블
# 유저
    #유저 id, 유저 이름, 닉,

# 컨텐츠
    # 프로젝트, 랭킹, 유저

# 게시판
    # 글 제목, 글 내용, 작성자

user = { 'name' = 'Jang', 'ID' = '0000', 'Nicd' = 'MadJangE'}
# >> 인자 항목 : name, ID, Nick
content = { "project" = "Life of Ants", "Rnak" = "order", "user" = "user"}
# >> 인자 항목 : project, Rank, user
board = { 'writer' = 'user', 'title' = 'article title', 'content' = 'article detail'}
# >> 인자 항목 : writer, title, content

## 클래스와 인스턴스

def makeClass(dicName, *('keys', 'props')):
     dicName = {'keys' : 'props'}
user.keys()


# 사람을 클래스로 두고
# 인수롤 프로퍼티를 두고
# 입력 받은 값으로 속성을 채운다.
# 채워지면 그게 객체, 인스턴스가 된다.
# 인스턴스의 고유값을 id를 매겨 관리하고
# 필요한 인스턴의의 id를 활용하여 불러와 필요한 정보를 활용한다.
# 인자 정보, 연산. 함수 정보, 결과 > 다시 인수로 저장?
# 표의 columns 는 속성, 키 값이 된다.
# 표의 row는 개체, 인스턴스가 되며 id로 구분 할 수 있어야 한다.
# 공통 사항은 columns으로 표현 하지만, 특이사항은 따로 기입해야 한다.

# 유저, 조건, 상수 및 독립 변수 데이터 테이블
# 함수 데이터 테이블
# 결과 종속 변수 데이터 테이블

# 일단 만들어 진행한다.
# 반복되는 것은 좀더 빠른 방법을 찾아본다.
# 기본적으로는 밸런스를 찾는 것이 중요하다.
# 그래야 운의 영역, 공략 되지 않는 영역에 둘 수 있다.
# 하지만 사람들은 공략이 가능한 것을 좋아 하기도 한다.
# 그런 영역도 남겨두되, 밸런스를 위해 보상을 조정한다.
# 모든 결과는 기록하여 최적 밸런스를 찾는 것을 지향한다.

# 입력하면 데이터를 테이블 형태로 모은다. 그리고 서버에 저장한다.
# 필요하면 서버에 저장한 정보를 가져와서 이용한다.
# 시간을 기록한다.
# 가장 단순한 형태의 저장 구조
# json
#